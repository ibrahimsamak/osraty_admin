{"remainingRequest":"/Users/ibrahimm.samak/Desktop/liken/CPanel-API/admin/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/ibrahimm.samak/Desktop/liken/CPanel-API/admin/node_modules/@nebular/theme/components/list/infinite-list.directive.js","dependencies":[{"path":"/Users/ibrahimm.samak/Desktop/liken/CPanel-API/admin/node_modules/@nebular/theme/components/list/infinite-list.directive.js","mtime":499162500000},{"path":"/Users/ibrahimm.samak/Desktop/liken/CPanel-API/admin/node_modules/cache-loader/dist/cjs.js","mtime":1541238936889},{"path":"/Users/ibrahimm.samak/Desktop/liken/CPanel-API/admin/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1525376550000}],"contextDependencies":[],"result":["import { Directive, Input, HostListener, ElementRef, EventEmitter, Output, ContentChildren, } from '@angular/core';\nimport { forkJoin, of as observableOf, interval, timer } from 'rxjs';\nimport { takeWhile, filter, switchMap, map, takeUntil, take } from 'rxjs/operators';\nimport { convertToBoolProperty } from '../helpers';\nimport { NbLayoutScrollService } from '../../services/scroll.service';\nimport { NbLayoutRulerService } from '../../services/ruler.service';\nimport { NbListItemComponent } from './list.component';\nvar NbScrollableContainerDimentions = /*@__PURE__*/ (function () {\n    function NbScrollableContainerDimentions() {\n    }\n    return NbScrollableContainerDimentions;\n}());\nexport { NbScrollableContainerDimentions };\n/**\n * Infinite List Directive\n *\n * ```html\n *  <nb-list nbInfiniteList [threshold]=\"500\" (bottomThreshold)=\"loadNext()\">\n *    <nb-list-item *ngFor=\"let item of items\"></nb-list-item>\n *  </nb-list>\n * ```\n *\n * @stacked-example(Simple infinite list, infinite-list/infinite-list-showcase.component)\n *\n * Directive will notify when list scrolled up or down to given a threshold.\n * By default it listen to scroll of list on which applied, but also can be set to listen to window scroll.\n *\n * @stacked-example(Scroll modes, infinite-list/infinite-list-scroll-modes.component)\n *\n * To improve UX of infinite lists, it's better to keep current page in url,\n * so user able to return to the last viewed page or to share a link to this page.\n * `nbListPageTracker` directive will help you to know, what page user currently viewing.\n * Just put it on a list, set page size and it will calculate page that currently in viewport.\n * You can [open the example](example/infinite-list/infinite-news-list.component)\n * in a new tab to check out this feature.\n *\n * @stacked-example(Infinite list with pager, infinite-list/infinite-news-list.component)\n *\n * @stacked-example(Infinite list with placeholders at the top, infinite-list/infinite-list-placeholders.component)\n *\n */\nvar NbInfiniteListDirective = /*@__PURE__*/ (function () {\n    function NbInfiniteListDirective(elementRef, scrollService, dimensionsService) {\n        this.elementRef = elementRef;\n        this.scrollService = scrollService;\n        this.dimensionsService = dimensionsService;\n        this.alive = true;\n        this.windowScroll = false;\n        /**\n           * Emits when distance between list bottom and current scroll position is less than threshold.\n           */\n        this.bottomThreshold = new EventEmitter(true);\n        /**\n           * Emits when distance between list top and current scroll position is less than threshold.\n           */\n        this.topThreshold = new EventEmitter(true);\n    }\n    Object.defineProperty(NbInfiniteListDirective.prototype, \"elementScroll\", {\n        get: function () {\n            return !this.windowScroll;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NbInfiniteListDirective.prototype, \"listenWindowScroll\", {\n        set: /**\n           * By default component observes list scroll position.\n           * If set to `true`, component will observe position of page scroll instead.\n           */ function (value) {\n            this.windowScroll = convertToBoolProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    NbInfiniteListDirective.prototype.onElementScroll = function () {\n        if (this.elementScroll) {\n            this.checkPosition(this.elementRef.nativeElement);\n        }\n    };\n    NbInfiniteListDirective.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        this.scrollService.onScroll()\n            .pipe(takeWhile(function () { return _this.alive; }), filter(function () { return _this.windowScroll; }), switchMap(function () { return _this.getContainerDimensions(); }))\n            .subscribe(function (dimentions) { return _this.checkPosition(dimentions); });\n        this.listItems.changes\n            .pipe(takeWhile(function () { return _this.alive; }), \n        // For some reason, changes are emitted before list item removed from dom,\n        // so dimensions will be incorrect.\n        // Check every 50ms for a second if dom and query are in sync.\n        // Once they synchronized, we can get proper dimensions.\n        switchMap(function () {\n            return interval(50).pipe(takeUntil(timer(1000)), filter(function () { return _this.inSyncWithDom(); }), take(1));\n        }), switchMap(function () { return _this.getContainerDimensions(); }))\n            .subscribe(function (dimentions) { return _this.checkPosition(dimentions); });\n        this.getContainerDimensions().subscribe(function (dimentions) { return _this.checkPosition(dimentions); });\n    };\n    NbInfiniteListDirective.prototype.ngOnDestroy = function () {\n        this.alive = false;\n    };\n    NbInfiniteListDirective.prototype.checkPosition = function (_a) {\n        var scrollHeight = _a.scrollHeight, scrollTop = _a.scrollTop, clientHeight = _a.clientHeight;\n        var initialCheck = this.lastScrollPosition == null;\n        var manualCheck = this.lastScrollPosition === scrollTop;\n        var scrollUp = scrollTop < this.lastScrollPosition;\n        var scrollDown = scrollTop > this.lastScrollPosition;\n        var distanceToBottom = scrollHeight - scrollTop - clientHeight;\n        if ((initialCheck || manualCheck || scrollDown) && distanceToBottom <= this.threshold) {\n            this.bottomThreshold.emit();\n        }\n        if ((initialCheck || scrollUp) && scrollTop <= this.threshold) {\n            this.topThreshold.emit();\n        }\n        this.lastScrollPosition = scrollTop;\n    };\n    NbInfiniteListDirective.prototype.getContainerDimensions = function () {\n        if (this.elementScroll) {\n            var _a = this.elementRef.nativeElement, scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;\n            return observableOf({ scrollTop: scrollTop, scrollHeight: scrollHeight, clientHeight: clientHeight });\n        }\n        return forkJoin(this.scrollService.getPosition(), this.dimensionsService.getDimensions())\n            .pipe(map(function (_a) {\n            var scrollPosition = _a[0], dimensions = _a[1];\n            return ({\n                scrollTop: scrollPosition.y,\n                scrollHeight: dimensions.scrollHeight,\n                clientHeight: dimensions.clientHeight,\n            });\n        }));\n    };\n    NbInfiniteListDirective.prototype.inSyncWithDom = function () {\n        return this.elementRef.nativeElement.children.length === this.listItems.length;\n    };\n    return NbInfiniteListDirective;\n}());\nexport { NbInfiniteListDirective };\n//# sourceMappingURL=infinite-list.directive.js.map\n",null]}