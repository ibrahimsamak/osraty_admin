{"remainingRequest":"/Users/ibrahimm.samak/Desktop/liken/CPanel-API/admin/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/ibrahimm.samak/Desktop/liken/CPanel-API/admin/node_modules/@nebular/theme/components/cdk/overlay/overlay-trigger.js","dependencies":[{"path":"/Users/ibrahimm.samak/Desktop/liken/CPanel-API/admin/node_modules/@nebular/theme/components/cdk/overlay/overlay-trigger.js","mtime":499162500000},{"path":"/Users/ibrahimm.samak/Desktop/liken/CPanel-API/admin/node_modules/cache-loader/dist/cjs.js","mtime":1541238936889},{"path":"/Users/ibrahimm.samak/Desktop/liken/CPanel-API/admin/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1525376550000}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\nimport { fromEvent as observableFromEvent, merge as observableMerge, Subject } from 'rxjs';\nimport { debounceTime, delay, filter, repeat, switchMap, takeUntil, takeWhile } from 'rxjs/operators';\nexport var NbTrigger;\n(function (NbTrigger) {\n    NbTrigger[\"CLICK\"] = \"click\";\n    NbTrigger[\"HOVER\"] = \"hover\";\n    NbTrigger[\"HINT\"] = \"hint\";\n    NbTrigger[\"FOCUS\"] = \"focus\";\n})(NbTrigger || (NbTrigger = {}));\n/**\n * Provides entity with two event stream: show and hide.\n * Each stream provides different events depends on implementation.\n * We have three main trigger strategies: click, hint and hover.\n * */\n/**\n * TODO maybe we have to use renderer.listen instead of observableFromEvent?\n * Renderer provides capability use it in service worker, ssr and so on.\n * */\nvar /**\n * Provides entity with two event stream: show and hide.\n * Each stream provides different events depends on implementation.\n * We have three main trigger strategies: click, hint and hover.\n * */ \n/**\n * TODO maybe we have to use renderer.listen instead of observableFromEvent?\n * Renderer provides capability use it in service worker, ssr and so on.\n * */\nNbTriggerStrategy = /*@__PURE__*/ (function () {\n    function NbTriggerStrategy(document, host, container) {\n        this.document = document;\n        this.host = host;\n        this.container = container;\n    }\n    return NbTriggerStrategy;\n}());\n/**\n * Provides entity with two event stream: show and hide.\n * Each stream provides different events depends on implementation.\n * We have three main trigger strategies: click, hint and hover.\n * */\n/**\n * TODO maybe we have to use renderer.listen instead of observableFromEvent?\n * Renderer provides capability use it in service worker, ssr and so on.\n * */\nexport { NbTriggerStrategy };\n/**\n * Creates show and hide event streams.\n * Fires toggle event when the click was performed on the host element.\n * Fires close event when the click was performed on the document but\n * not on the host or container.\n * */\nvar /**\n * Creates show and hide event streams.\n * Fires toggle event when the click was performed on the host element.\n * Fires close event when the click was performed on the document but\n * not on the host or container.\n * */ NbClickTriggerStrategy = /*@__PURE__*/ (function (_super) {\n    __extends(NbClickTriggerStrategy, _super);\n    function NbClickTriggerStrategy(document, host, container) {\n        var _this = _super.call(this, document, host, container) || this;\n        _this.document = document;\n        _this.host = host;\n        _this.container = container;\n        _this.show = new Subject();\n        _this.show$ = _this.show.asObservable();\n        _this.hide = new Subject();\n        _this.hide$ = observableMerge(_this.hide.asObservable(), observableFromEvent(_this.document, 'click')\n            .pipe(filter(function (event) { return _this.isNotHostOrContainer(event); })));\n        _this.subscribeOnHostClick();\n        return _this;\n    }\n    NbClickTriggerStrategy.prototype.subscribeOnHostClick = function () {\n        var _this = this;\n        observableFromEvent(this.host, 'click')\n            .subscribe(function (event) {\n            if (_this.isContainerExists()) {\n                _this.hide.next(event);\n            }\n            else {\n                _this.show.next(event);\n            }\n        });\n    };\n    NbClickTriggerStrategy.prototype.isContainerExists = function () {\n        return !!this.container();\n    };\n    NbClickTriggerStrategy.prototype.isNotHostOrContainer = function (event) {\n        return !this.host.contains(event.target)\n            && this.isContainerExists()\n            && !this.container().location.nativeElement.contains(event.target);\n    };\n    return NbClickTriggerStrategy;\n}(NbTriggerStrategy));\n/**\n * Creates show and hide event streams.\n * Fires toggle event when the click was performed on the host element.\n * Fires close event when the click was performed on the document but\n * not on the host or container.\n * */\nexport { NbClickTriggerStrategy };\n/**\n * Creates show and hide event streams.\n * Fires open event when a mouse hovers over the host element and stay over at least 100 milliseconds.\n * Fires close event when the mouse leaves the host element and stops out of the host and popover container.\n * */\nvar /**\n * Creates show and hide event streams.\n * Fires open event when a mouse hovers over the host element and stay over at least 100 milliseconds.\n * Fires close event when the mouse leaves the host element and stops out of the host and popover container.\n * */ NbHoverTriggerStrategy = /*@__PURE__*/ (function (_super) {\n    __extends(NbHoverTriggerStrategy, _super);\n    function NbHoverTriggerStrategy() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.show$ = observableFromEvent(_this.host, 'mouseenter')\n            .pipe(delay(100), takeUntil(observableFromEvent(_this.host, 'mouseleave')), repeat());\n        _this.hide$ = observableFromEvent(_this.host, 'mouseleave')\n            .pipe(switchMap(function () {\n            return observableFromEvent(_this.document, 'mousemove')\n                .pipe(debounceTime(100), takeWhile(function () { return !!_this.container(); }), filter(function (event) {\n                return !_this.host.contains(event.target)\n                    && !_this.container().location.nativeElement.contains(event.target);\n            }));\n        }));\n        return _this;\n    }\n    return NbHoverTriggerStrategy;\n}(NbTriggerStrategy));\n/**\n * Creates show and hide event streams.\n * Fires open event when a mouse hovers over the host element and stay over at least 100 milliseconds.\n * Fires close event when the mouse leaves the host element and stops out of the host and popover container.\n * */\nexport { NbHoverTriggerStrategy };\n/**\n * Creates show and hide event streams.\n * Fires open event when a mouse hovers over the host element and stay over at least 100 milliseconds.\n * Fires close event when the mouse leaves the host element.\n * */\nvar /**\n * Creates show and hide event streams.\n * Fires open event when a mouse hovers over the host element and stay over at least 100 milliseconds.\n * Fires close event when the mouse leaves the host element.\n * */ NbHintTriggerStrategy = /*@__PURE__*/ (function (_super) {\n    __extends(NbHintTriggerStrategy, _super);\n    function NbHintTriggerStrategy() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.show$ = observableFromEvent(_this.host, 'mouseenter')\n            .pipe(delay(100), takeUntil(observableFromEvent(_this.host, 'mouseleave')), repeat());\n        _this.hide$ = observableFromEvent(_this.host, 'mouseleave');\n        return _this;\n    }\n    return NbHintTriggerStrategy;\n}(NbTriggerStrategy));\n/**\n * Creates show and hide event streams.\n * Fires open event when a mouse hovers over the host element and stay over at least 100 milliseconds.\n * Fires close event when the mouse leaves the host element.\n * */\nexport { NbHintTriggerStrategy };\n/**\n * Creates show and hide event streams.\n * Fires open event when a focus is on the host element and stay over at least 100 milliseconds.\n * Fires close event when the focus leaves the host element.\n * */\nvar /**\n * Creates show and hide event streams.\n * Fires open event when a focus is on the host element and stay over at least 100 milliseconds.\n * Fires close event when the focus leaves the host element.\n * */ NbFocusTriggerStrategy = /*@__PURE__*/ (function (_super) {\n    __extends(NbFocusTriggerStrategy, _super);\n    function NbFocusTriggerStrategy() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.focusOut$ = observableFromEvent(_this.host, 'focusout')\n            .pipe(switchMap(function () {\n            return observableFromEvent(_this.document, 'focusin')\n                .pipe(takeWhile(function () { return !!_this.container(); }), filter(function (event) { return _this.isNotOnHostOrContainer(event); }));\n        }));\n        _this.clickIn$ = observableFromEvent(_this.host, 'click')\n            .pipe(filter(function () { return !_this.container(); }));\n        _this.clickOut$ = observableFromEvent(_this.document, 'click')\n            .pipe(filter(function () { return !!_this.container(); }), filter(function (event) { return _this.isNotOnHostOrContainer(event); }));\n        _this.tabKeyPress$ = observableFromEvent(_this.document, 'keydown')\n            .pipe(filter(function (event) { return event.keyCode === 9; }), filter(function () { return !!_this.container(); }));\n        _this.show$ = observableMerge(observableFromEvent(_this.host, 'focusin'), _this.clickIn$)\n            .pipe(filter(function () { return !_this.container(); }), debounceTime(100), takeUntil(observableFromEvent(_this.host, 'focusout')), repeat());\n        _this.hide$ = observableMerge(_this.focusOut$, _this.tabKeyPress$, _this.clickOut$);\n        return _this;\n    }\n    NbFocusTriggerStrategy.prototype.isNotOnHostOrContainer = function (event) {\n        return !this.isOnHost(event) && !this.isOnContainer(event);\n    };\n    NbFocusTriggerStrategy.prototype.isOnHost = function (_a) {\n        var target = _a.target;\n        return this.host.contains(target);\n    };\n    NbFocusTriggerStrategy.prototype.isOnContainer = function (_a) {\n        var target = _a.target;\n        return this.container() && this.container().location.nativeElement.contains(target);\n    };\n    return NbFocusTriggerStrategy;\n}(NbTriggerStrategy));\n/**\n * Creates show and hide event streams.\n * Fires open event when a focus is on the host element and stay over at least 100 milliseconds.\n * Fires close event when the focus leaves the host element.\n * */\nexport { NbFocusTriggerStrategy };\nvar NbTriggerStrategyBuilder = /*@__PURE__*/ (function () {\n    function NbTriggerStrategyBuilder() {\n    }\n    NbTriggerStrategyBuilder.prototype.document = function (document) {\n        this._document = document;\n        return this;\n    };\n    NbTriggerStrategyBuilder.prototype.trigger = function (trigger) {\n        this._trigger = trigger;\n        return this;\n    };\n    NbTriggerStrategyBuilder.prototype.host = function (host) {\n        this._host = host;\n        return this;\n    };\n    NbTriggerStrategyBuilder.prototype.container = function (container) {\n        this._container = container;\n        return this;\n    };\n    NbTriggerStrategyBuilder.prototype.build = function () {\n        switch (this._trigger) {\n            case NbTrigger.CLICK:\n                return new NbClickTriggerStrategy(this._document, this._host, this._container);\n            case NbTrigger.HINT:\n                return new NbHintTriggerStrategy(this._document, this._host, this._container);\n            case NbTrigger.HOVER:\n                return new NbHoverTriggerStrategy(this._document, this._host, this._container);\n            case NbTrigger.FOCUS:\n                return new NbFocusTriggerStrategy(this._document, this._host, this._container);\n            default:\n                throw new Error('Trigger have to be provided');\n        }\n    };\n    return NbTriggerStrategyBuilder;\n}());\nexport { NbTriggerStrategyBuilder };\n//# sourceMappingURL=overlay-trigger.js.map\n",null]}