{"remainingRequest":"/Users/ibrahimm.samak/Desktop/liken/CPanel-API/admin/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/ibrahimm.samak/Desktop/liken/CPanel-API/admin/node_modules/@nebular/theme/components/cdk/overlay/overlay-position.js","dependencies":[{"path":"/Users/ibrahimm.samak/Desktop/liken/CPanel-API/admin/node_modules/@nebular/theme/components/cdk/overlay/overlay-position.js","mtime":499162500000},{"path":"/Users/ibrahimm.samak/Desktop/liken/CPanel-API/admin/node_modules/cache-loader/dist/cjs.js","mtime":1541238936889},{"path":"/Users/ibrahimm.samak/Desktop/liken/CPanel-API/admin/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1525376550000}],"contextDependencies":[],"result":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Inject, Injectable } from '@angular/core';\nimport { map } from 'rxjs/operators';\nimport { NB_DOCUMENT } from '../../../theme.options';\nimport { NbFlexibleConnectedPositionStrategy, NbOverlayPositionBuilder, NbPlatform, } from './mapping';\nimport { NbViewportRulerAdapter } from '../adapter/viewport-ruler-adapter';\nimport { NbGlobalLogicalPosition } from './position-helper';\nimport { GlobalPositionStrategy } from '@angular/cdk/overlay';\nexport var NbAdjustment;\n(function (NbAdjustment) {\n    NbAdjustment[\"NOOP\"] = \"noop\";\n    NbAdjustment[\"CLOCKWISE\"] = \"clockwise\";\n    NbAdjustment[\"COUNTERCLOCKWISE\"] = \"counterclockwise\";\n    NbAdjustment[\"VERTICAL\"] = \"vertical\";\n    NbAdjustment[\"HORIZONTAL\"] = \"horizontal\";\n})(NbAdjustment || (NbAdjustment = {}));\nexport var NbPosition;\n(function (NbPosition) {\n    NbPosition[\"TOP\"] = \"top\";\n    NbPosition[\"BOTTOM\"] = \"bottom\";\n    NbPosition[\"LEFT\"] = \"left\";\n    NbPosition[\"RIGHT\"] = \"right\";\n    NbPosition[\"START\"] = \"start\";\n    NbPosition[\"END\"] = \"end\";\n})(NbPosition || (NbPosition = {}));\nvar POSITIONS = (_a = {},\n    _a[NbPosition.RIGHT] = function (offset) {\n        return { originX: 'end', originY: 'center', overlayX: 'start', overlayY: 'center', offsetX: offset };\n    },\n    _a[NbPosition.BOTTOM] = function (offset) {\n        return { originX: 'center', originY: 'bottom', overlayX: 'center', overlayY: 'top', offsetY: offset };\n    },\n    _a[NbPosition.LEFT] = function (offset) {\n        return { originX: 'start', originY: 'center', overlayX: 'end', overlayY: 'center', offsetX: -offset };\n    },\n    _a[NbPosition.TOP] = function (offset) {\n        return { originX: 'center', originY: 'top', overlayX: 'center', overlayY: 'bottom', offsetY: -offset };\n    },\n    _a);\nvar COUNTER_CLOCKWISE_POSITIONS = [NbPosition.TOP, NbPosition.LEFT, NbPosition.BOTTOM, NbPosition.RIGHT];\nvar NOOP_POSITIONS = [NbPosition.TOP, NbPosition.BOTTOM, NbPosition.LEFT, NbPosition.RIGHT];\nvar CLOCKWISE_POSITIONS = [NbPosition.TOP, NbPosition.RIGHT, NbPosition.BOTTOM, NbPosition.LEFT];\nvar VERTICAL_POSITIONS = [NbPosition.BOTTOM, NbPosition.TOP];\nvar HORIZONTAL_POSITIONS = [NbPosition.START, NbPosition.END];\nfunction comparePositions(p1, p2) {\n    return p1.originX === p2.originX\n        && p1.originY === p2.originY\n        && p1.overlayX === p2.overlayX\n        && p1.overlayY === p2.overlayY;\n}\n/**\n * The main idea of the adjustable connected strategy is to provide predefined set of positions for your overlay.\n * You have to provide adjustment and appropriate strategy will be chosen in runtime.\n * */\nvar /**\n * The main idea of the adjustable connected strategy is to provide predefined set of positions for your overlay.\n * You have to provide adjustment and appropriate strategy will be chosen in runtime.\n * */ NbAdjustableConnectedPositionStrategy = /*@__PURE__*/ (function (_super) {\n    __extends(NbAdjustableConnectedPositionStrategy, _super);\n    function NbAdjustableConnectedPositionStrategy() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._offset = 15;\n        _this.positionChange = _this.positionChanges.pipe(map(function (positionChange) { return positionChange.connectionPair; }), map(function (connectionPair) {\n            return _this.appliedPositions.find(function (_a) {\n                var connectedPosition = _a.connectedPosition;\n                return comparePositions(connectedPosition, connectionPair);\n            }).key;\n        }));\n        return _this;\n    }\n    NbAdjustableConnectedPositionStrategy.prototype.attach = function (overlayRef) {\n        /**\n             * We have to apply positions before attach because super.attach() validates positions and crashes app\n             * if no positions provided.\n             * */\n        this.applyPositions();\n        _super.prototype.attach.call(this, overlayRef);\n    };\n    NbAdjustableConnectedPositionStrategy.prototype.apply = function () {\n        this.applyPositions();\n        _super.prototype.apply.call(this);\n    };\n    NbAdjustableConnectedPositionStrategy.prototype.position = function (position) {\n        this._position = position;\n        return this;\n    };\n    NbAdjustableConnectedPositionStrategy.prototype.adjustment = function (adjustment) {\n        this._adjustment = adjustment;\n        return this;\n    };\n    NbAdjustableConnectedPositionStrategy.prototype.offset = function (offset) {\n        this._offset = offset;\n        return this;\n    };\n    NbAdjustableConnectedPositionStrategy.prototype.applyPositions = function () {\n        var positions = this.createPositions();\n        this.persistChosenPositions(positions);\n        this.withPositions(this.appliedPositions.map(function (_a) {\n            var connectedPosition = _a.connectedPosition;\n            return connectedPosition;\n        }));\n    };\n    NbAdjustableConnectedPositionStrategy.prototype.createPositions = function () {\n        var _this = this;\n        switch (this._adjustment) {\n            case NbAdjustment.NOOP:\n                return NOOP_POSITIONS.filter(function (position) { return _this._position === position; });\n            case NbAdjustment.CLOCKWISE:\n                return this.reorderPreferredPositions(CLOCKWISE_POSITIONS);\n            case NbAdjustment.COUNTERCLOCKWISE:\n                return this.reorderPreferredPositions(COUNTER_CLOCKWISE_POSITIONS);\n            case NbAdjustment.HORIZONTAL:\n                return this.reorderPreferredPositions(HORIZONTAL_POSITIONS);\n            case NbAdjustment.VERTICAL:\n                return this.reorderPreferredPositions(VERTICAL_POSITIONS);\n        }\n    };\n    NbAdjustableConnectedPositionStrategy.prototype.persistChosenPositions = function (positions) {\n        var _this = this;\n        this.appliedPositions = positions.map(function (position) {\n            return ({\n                key: position,\n                connectedPosition: POSITIONS[position](_this._offset),\n            });\n        });\n    };\n    NbAdjustableConnectedPositionStrategy.prototype.reorderPreferredPositions = function (positions) {\n        var cpy = positions.slice();\n        var startIndex = positions.indexOf(this._position);\n        var start = cpy.splice(startIndex);\n        return start.concat.apply(start, cpy);\n    };\n    return NbAdjustableConnectedPositionStrategy;\n}(NbFlexibleConnectedPositionStrategy));\n/**\n * The main idea of the adjustable connected strategy is to provide predefined set of positions for your overlay.\n * You have to provide adjustment and appropriate strategy will be chosen in runtime.\n * */\nexport { NbAdjustableConnectedPositionStrategy };\nvar NbGlobalPositionStrategy = /*@__PURE__*/ (function (_super) {\n    __extends(NbGlobalPositionStrategy, _super);\n    function NbGlobalPositionStrategy() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NbGlobalPositionStrategy.prototype.position = function (position) {\n        switch (position) {\n            case NbGlobalLogicalPosition.TOP_START:\n                return this.top().left();\n            case NbGlobalLogicalPosition.TOP_END:\n                return this.top().right();\n            case NbGlobalLogicalPosition.BOTTOM_START:\n                return this.bottom().left();\n            case NbGlobalLogicalPosition.BOTTOM_END:\n                return this.bottom().right();\n        }\n    };\n    return NbGlobalPositionStrategy;\n}(GlobalPositionStrategy));\nexport { NbGlobalPositionStrategy };\nvar NbPositionBuilderService = /*@__PURE__*/ (function () {\n    function NbPositionBuilderService(document, viewportRuler, platform, positionBuilder) {\n        this.document = document;\n        this.viewportRuler = viewportRuler;\n        this.platform = platform;\n        this.positionBuilder = positionBuilder;\n    }\n    NbPositionBuilderService.prototype.global = function () {\n        return new NbGlobalPositionStrategy();\n    };\n    NbPositionBuilderService.prototype.connectedTo = function (elementRef) {\n        return new NbAdjustableConnectedPositionStrategy(elementRef, this.viewportRuler, this.document, this.platform)\n            .withFlexibleDimensions(false)\n            .withPush(false);\n    };\n    return NbPositionBuilderService;\n}());\nexport { NbPositionBuilderService };\nvar _a;\n//# sourceMappingURL=overlay-position.js.map\n",null]}