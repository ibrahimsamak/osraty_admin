{"remainingRequest":"/Users/ibrahimm.samak/Desktop/liken/CPanel-API/admin/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/ibrahimm.samak/Desktop/liken/CPanel-API/admin/node_modules/@nebular/theme/components/layout/layout.component.js","dependencies":[{"path":"/Users/ibrahimm.samak/Desktop/liken/CPanel-API/admin/node_modules/@nebular/theme/components/layout/layout.component.js","mtime":499162500000},{"path":"/Users/ibrahimm.samak/Desktop/liken/CPanel-API/admin/node_modules/cache-loader/dist/cjs.js","mtime":1541238936889},{"path":"/Users/ibrahimm.samak/Desktop/liken/CPanel-API/admin/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1525376550000}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\nimport { Component, ElementRef, HostBinding, HostListener, Input, Renderer2, ViewChild, ViewContainerRef, Inject, PLATFORM_ID, forwardRef, } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { BehaviorSubject } from 'rxjs';\nimport { filter, takeWhile } from 'rxjs/operators';\nimport { convertToBoolProperty } from '../helpers';\nimport { NbThemeService } from '../../services/theme.service';\nimport { NbSpinnerService } from '../../services/spinner.service';\nimport { NbLayoutDirectionService } from '../../services/direction.service';\nimport { NbRestoreScrollTopHelper } from './restore-scroll-top.service';\nimport { NbLayoutScrollService } from '../../services/scroll.service';\nimport { NbLayoutRulerService } from '../../services/ruler.service';\nimport { NB_WINDOW, NB_DOCUMENT } from '../../theme.options';\nimport { NbOverlayContainerAdapter } from '../cdk/adapter/overlay-container-adapter';\n/**\n * A container component which determines a content position inside of the layout.\n * The layout could contain unlimited columns (not including the sidebars).\n *\n * By default the columns are ordered from the left to the right,\n * but it's also possible to overwrite this behavior by setting a `left` attribute to the column,\n * moving it to the very first position:\n *\n * @stacked-example(Column Left, layout/layout-column-left.component)\n */\nvar NbLayoutColumnComponent = /*@__PURE__*/ (function () {\n    function NbLayoutColumnComponent() {\n    }\n    Object.defineProperty(NbLayoutColumnComponent.prototype, \"left\", {\n        set: /**\n           * Move the column to the very left position in the layout.\n           * @param {boolean} val\n           */ function (val) {\n            this.leftValue = convertToBoolProperty(val);\n            this.startValue = false;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NbLayoutColumnComponent.prototype, \"start\", {\n        set: /**\n           * Make columnt first in the layout.\n           * @param {boolean} val\n           */ function (val) {\n            this.startValue = convertToBoolProperty(val);\n            this.leftValue = false;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return NbLayoutColumnComponent;\n}());\nexport { NbLayoutColumnComponent };\n/**\n * Page header component.\n * Located on top of the page above the layout columns and sidebars.\n * Could be made `fixed` by setting the corresponding property. In the fixed mode the header becomes\n * sticky to the top of the nb-layout (to of the page). Here's an example:\n *\n * @stacked-example(Fixed Header, layout/layout-fixed-header.component)\n *\n * In a pair with sidebar it is possible to setup a configuration when header is placed on a side of the sidebar\n * and not on top of it. To achieve this simply put a `subheader` property to the header like this:\n * ```html\n * <nb-layout-header subheader></nb-layout-header>\n * ```\n * @stacked-example(Subheader, layout/layout-sidebar-subheader.component)\n * Note that in such configuration sidebar shadow is removed and header cannot be make `fixed`.\n *\n * Same way you can put both `fixed` and `clipped` headers adding creating a sub-header for your app:\n *\n * @stacked-example(Subheader, layout/layout-subheader.component)\n *\n * @styles\n *\n * header-font-family\n * header-line-height\n * header-fg\n * header-bg\n * header-height\n * header-padding\n * header-shadow\n */\nvar NbLayoutHeaderComponent = /*@__PURE__*/ (function () {\n    // tslint:disable-next-line\n    function NbLayoutHeaderComponent(layout) {\n        this.layout = layout;\n    }\n    Object.defineProperty(NbLayoutHeaderComponent.prototype, \"fixed\", {\n        set: /**\n           * Makes the header sticky to the top of the nb-layout.\n           * @param {boolean} val\n           */ function (val) {\n            this.fixedValue = convertToBoolProperty(val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NbLayoutHeaderComponent.prototype, \"subheader\", {\n        set: /**\n           * Places header on a side of the sidebar, and not above.\n           * Disables fixed mode for this header and remove a shadow from the sidebar.\n           * @param {boolean} val\n           */ function (val) {\n            this.subheaderValue = convertToBoolProperty(val);\n            this.fixedValue = false;\n            this.layout.withSubheader = this.subheaderValue;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return NbLayoutHeaderComponent;\n}());\nexport { NbLayoutHeaderComponent };\n/**\n * Page footer.\n * Located under the nb-layout content (specifically, under the columns).\n * Could be made `fixed`, becoming sticky to the bottom of the view port (window).\n *\n * @styles\n *\n * footer-height\n * footer-padding\n * footer-fg\n * footer-bg\n * footer-separator\n * footer-shadow\n */\nvar NbLayoutFooterComponent = /*@__PURE__*/ (function () {\n    function NbLayoutFooterComponent() {\n    }\n    Object.defineProperty(NbLayoutFooterComponent.prototype, \"fixed\", {\n        set: /**\n           * Makes the footer sticky to the bottom of the window.\n           * @param {boolean} val\n           */ function (val) {\n            this.fixedValue = convertToBoolProperty(val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return NbLayoutFooterComponent;\n}());\nexport { NbLayoutFooterComponent };\n/**\n * Layout container component.\n * When using with Nebular Theme System it is required that all child components should be placed inside.\n *\n * Basic example of two column layout with header:\n *\n * @stacked-example(Showcase, layout/layout-showcase.component)\n *\n * Can contain the following components inside:\n *\n * ```html\n * <nb-layout>\n *  <nb-layout-header></nb-layout-header>\n *  <nb-layout-footer></nb-layout-column>\n *  <nb-layout-column></nb-layout-column>\n *  <nb-sidebar></nb-sidebar>\n * </nb-layout>\n * ```\n * ### Installation\n *\n * Import `NbLayoutModule.forRoot()` to your app module.\n * ```ts\n * @NgModule({\n *   imports: [\n *   \t// ...\n *     NbLayoutModule.forRoot(),\n *   ],\n * })\n * export class AppModule { }\n * ```\n * and `NbLayoutModule` to your feature module where the component should be shown:\n * ```ts\n * @NgModule({\n *   imports: [\n *   \t// ...\n *     NbLayoutModule,\n *   ],\n * })\n * export class PageModule { }\n * ```\n * ### Usage\n * By default the layout fills up the whole view-port.\n * The window scrollbars are disabled on the body and moved inside of the nb-layout, so that the scrollbars\n * won't mess with the fixed nb-header.\n *\n * The child components are projected into a flexible layout structure allowing to adjust the layout behavior\n * based on the settings provided.\n *\n * The layout content (columns) becomes centered when the window width is more than\n * the value specified in the theme variable `layout-content-width`.\n *\n * The layout also contains the area on the very top (the first child of the nb-layout), which could be used\n * to dynamically append some components like modals or spinners/loaders\n * so that they are located on top of the elements hierarchy.\n * More details are under the `ThemeService` section.\n *\n * The layout component is also responsible for changing application themes.\n * It listens to the `themeChange` event and change a theme CSS class appended to body.\n * Based on the class appended, specific CSS-theme is applied to the application.\n * More details of the Theme System could be found here [Enabling Theme System](#/docs/concepts/theme-system)\n *\n * A simple layout with footer:\n *\n * @stacked-example(Layout With Footer, layout/layout-w-footer.component)\n *\n * It is possible to ask the layout to center the columns (notice: we added a `center` attribute\n * to the layout:\n *\n * ```html\n * <nb-layout center>\n *   <nb-layout-header>Awesome Company</nb-layout-header>\n *\n *   <nb-layout-column>\n *     Hello World!\n *   </nb-layout-column>\n *\n *   <nb-layout-footer>Contact us</nb-layout-footer>\n * </nb-layout>\n * ```\n *\n * @styles\n *\n * layout-font-family\n * layout-font-size\n * layout-line-height\n * layout-fg\n * layout-bg\n * layout-min-height\n * layout-content-width\n * layout-window-mode-min-width\n * layout-window-mode-max-width: window mode only, after this value layout turns into a floating window\n * layout-window-mode-bg: window mode only, background\n * layout-window-mode-padding-top: window mode only, max padding from top\n * layout-window-shadow: window mode shadow\n * layout-padding\n * layout-medium-padding\n * layout-small-padding\n */\nvar NbLayoutComponent = /*@__PURE__*/ (function () {\n    function NbLayoutComponent(themeService, spinnerService, elementRef, renderer, window, document, platformId, layoutDirectionService, scrollService, rulerService, scrollTop, overlayContainer) {\n        var _this = this;\n        this.themeService = themeService;\n        this.spinnerService = spinnerService;\n        this.elementRef = elementRef;\n        this.renderer = renderer;\n        this.window = window;\n        this.document = document;\n        this.platformId = platformId;\n        this.layoutDirectionService = layoutDirectionService;\n        this.scrollService = scrollService;\n        this.rulerService = rulerService;\n        this.scrollTop = scrollTop;\n        this.overlayContainer = overlayContainer;\n        this.centerValue = false;\n        this.restoreScrollTopValue = true;\n        this.windowModeValue = false;\n        this.withScrollValue = false;\n        this.withSubheader = false;\n        this.afterViewInit$ = new BehaviorSubject(null);\n        this.alive = true;\n        this.registerAsOverlayContainer();\n        this.themeService.onThemeChange()\n            .pipe(takeWhile(function () { return _this.alive; }))\n            .subscribe(function (theme) {\n            var body = _this.document.getElementsByTagName('body')[0];\n            if (theme.previous) {\n                _this.renderer.removeClass(body, \"nb-theme-\" + theme.previous);\n            }\n            _this.renderer.addClass(body, \"nb-theme-\" + theme.name);\n        });\n        this.themeService.onAppendLayoutClass()\n            .pipe(takeWhile(function () { return _this.alive; }))\n            .subscribe(function (className) {\n            _this.renderer.addClass(_this.elementRef.nativeElement, className);\n        });\n        this.themeService.onRemoveLayoutClass()\n            .pipe(takeWhile(function () { return _this.alive; }))\n            .subscribe(function (className) {\n            _this.renderer.removeClass(_this.elementRef.nativeElement, className);\n        });\n        this.spinnerService.registerLoader(new Promise(function (resolve, reject) {\n            _this.afterViewInit$\n                .pipe(takeWhile(function () { return _this.alive; }))\n                .subscribe(function (_) { return resolve(); });\n        }));\n        this.spinnerService.load();\n        this.rulerService.onGetDimensions()\n            .pipe(takeWhile(function () { return _this.alive; }))\n            .subscribe(function (_a) {\n            var listener = _a.listener;\n            listener.next(_this.getDimensions());\n            listener.complete();\n        });\n        this.scrollService.onGetPosition()\n            .pipe(takeWhile(function () { return _this.alive; }))\n            .subscribe(function (_a) {\n            var listener = _a.listener;\n            listener.next(_this.getScrollPosition());\n            listener.complete();\n        });\n        this.scrollTop\n            .shouldRestore()\n            .pipe(filter(function () { return _this.restoreScrollTopValue; }), takeWhile(function () { return _this.alive; }))\n            .subscribe(function () {\n            _this.scroll(0, 0);\n        });\n        if (isPlatformBrowser(this.platformId)) {\n            // trigger first time so that after the change we have the initial value\n            this.themeService.changeWindowWidth(this.window.innerWidth);\n        }\n    }\n    Object.defineProperty(NbLayoutComponent.prototype, \"center\", {\n        set: /**\n           * Defines whether the layout columns will be centered after some width\n           * @param {boolean} val\n           */ function (val) {\n            this.centerValue = convertToBoolProperty(val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NbLayoutComponent.prototype, \"windowMode\", {\n        set: /**\n           * Defines whether the layout enters a 'window' mode, when the layout content (including sidebars and fixed header)\n           * becomes centered by width with a margin from the top of the screen, like a floating window.\n           * Automatically enables `withScroll` mode, as in the window mode scroll must be inside the layout and cannot be on\n           * window. (TODO: check this)\n           * @param {boolean} val\n           */ function (val) {\n            this.windowModeValue = convertToBoolProperty(val);\n            this.withScroll = this.windowModeValue;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NbLayoutComponent.prototype, \"withScroll\", {\n        set: /**\n           * Defines whether to move the scrollbars to layout or leave it at the body level.\n           * Automatically set to true when `windowMode` is enabled.\n           * @param {boolean} val\n           */ function (val) {\n            this.withScrollValue = convertToBoolProperty(val);\n            // TODO: is this the best way of doing it? as we don't have access to body from theme styles\n            // TODO: add e2e test\n            var body = this.document.getElementsByTagName('body')[0];\n            if (this.withScrollValue) {\n                this.renderer.setStyle(body, 'overflow', 'hidden');\n            }\n            else {\n                this.renderer.setStyle(body, 'overflow', 'initial');\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NbLayoutComponent.prototype, \"restoreScrollTop\", {\n        set: /**\n           * Restores scroll to the top of the page after navigation\n           * @param {boolean} val\n           */ function (val) {\n            this.restoreScrollTopValue = convertToBoolProperty(val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    NbLayoutComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        this.layoutDirectionService.onDirectionChange()\n            .pipe(takeWhile(function () { return _this.alive; }))\n            .subscribe(function (direction) {\n            _this.renderer.setProperty(_this.document, 'dir', direction);\n        });\n        this.scrollService.onManualScroll()\n            .pipe(takeWhile(function () { return _this.alive; }))\n            .subscribe(function (_a) {\n            var x = _a.x, y = _a.y;\n            return _this.scroll(x, y);\n        });\n        this.afterViewInit$.next(true);\n    };\n    NbLayoutComponent.prototype.ngOnDestroy = function () {\n        this.alive = false;\n        this.unregisterAsOverlayContainer();\n    };\n    NbLayoutComponent.prototype.onScroll = function ($event) {\n        this.scrollService.fireScrollChange($event);\n    };\n    NbLayoutComponent.prototype.onResize = function (event) {\n        this.themeService.changeWindowWidth(event.target.innerWidth);\n    };\n    /**\n     * Returns scroll and client height/width\n     *\n     * Depending on the current scroll mode (`withScroll=true`) returns sizes from the body element\n     * or from the `.scrollable-container`\n     * @returns {NbLayoutDimensions}\n     */\n    /**\n       * Returns scroll and client height/width\n       *\n       * Depending on the current scroll mode (`withScroll=true`) returns sizes from the body element\n       * or from the `.scrollable-container`\n       * @returns {NbLayoutDimensions}\n       */\n    NbLayoutComponent.prototype.getDimensions = /**\n       * Returns scroll and client height/width\n       *\n       * Depending on the current scroll mode (`withScroll=true`) returns sizes from the body element\n       * or from the `.scrollable-container`\n       * @returns {NbLayoutDimensions}\n       */\n        function () {\n            var clientWidth, clientHeight, scrollWidth, scrollHeight = 0;\n            if (this.withScrollValue) {\n                var container = this.scrollableContainerRef.nativeElement;\n                clientWidth = container.clientWidth;\n                clientHeight = container.clientHeight;\n                scrollWidth = container.scrollWidth;\n                scrollHeight = container.scrollHeight;\n            }\n            else {\n                var _a = this.document, documentElement = _a.documentElement, body = _a.body;\n                clientWidth = documentElement.clientWidth || body.clientWidth;\n                clientHeight = documentElement.clientHeight || body.clientHeight;\n                scrollWidth = documentElement.scrollWidth || body.scrollWidth;\n                scrollHeight = documentElement.scrollHeight || body.scrollHeight;\n            }\n            return {\n                clientWidth: clientWidth,\n                clientHeight: clientHeight,\n                scrollWidth: scrollWidth,\n                scrollHeight: scrollHeight,\n            };\n        };\n    /**\n     * Returns scroll position of current scroll container.\n     *\n     * If `withScroll` = true, returns scroll position of the `.scrollable-container` element,\n     * otherwise - of the scrollable element of the window (which may be different depending of a browser)\n     *\n     * @returns {NbScrollPosition}\n     */\n    /**\n       * Returns scroll position of current scroll container.\n       *\n       * If `withScroll` = true, returns scroll position of the `.scrollable-container` element,\n       * otherwise - of the scrollable element of the window (which may be different depending of a browser)\n       *\n       * @returns {NbScrollPosition}\n       */\n    NbLayoutComponent.prototype.getScrollPosition = /**\n       * Returns scroll position of current scroll container.\n       *\n       * If `withScroll` = true, returns scroll position of the `.scrollable-container` element,\n       * otherwise - of the scrollable element of the window (which may be different depending of a browser)\n       *\n       * @returns {NbScrollPosition}\n       */\n        function () {\n            if (this.withScrollValue) {\n                var container = this.scrollableContainerRef.nativeElement;\n                return { x: container.scrollLeft, y: container.scrollTop };\n            }\n            var documentRect = this.document.documentElement.getBoundingClientRect();\n            var x = -documentRect.left || this.document.body.scrollLeft || this.window.scrollX ||\n                this.document.documentElement.scrollLeft || 0;\n            var y = -documentRect.top || this.document.body.scrollTop || this.window.scrollY ||\n                this.document.documentElement.scrollTop || 0;\n            return { x: x, y: y };\n        };\n    NbLayoutComponent.prototype.registerAsOverlayContainer = function () {\n        if (this.overlayContainer.setContainer) {\n            this.overlayContainer.setContainer(this.elementRef.nativeElement);\n        }\n    };\n    NbLayoutComponent.prototype.unregisterAsOverlayContainer = function () {\n        if (this.overlayContainer.clearContainer) {\n            this.overlayContainer.clearContainer();\n        }\n    };\n    NbLayoutComponent.prototype.scroll = function (x, y) {\n        if (x === void 0) {\n            x = null;\n        }\n        if (y === void 0) {\n            y = null;\n        }\n        var _a = this.getScrollPosition(), currentX = _a.x, currentY = _a.y;\n        x = x == null ? currentX : x;\n        y = y == null ? currentY : y;\n        if (!isPlatformBrowser(this.platformId)) {\n            return;\n        }\n        if (this.withScrollValue) {\n            var scrollable = this.scrollableContainerRef.nativeElement;\n            if (scrollable.scrollTo) {\n                scrollable.scrollTo(x, y);\n            }\n            else {\n                scrollable.scrollLeft = x;\n                scrollable.scrollTop = y;\n            }\n        }\n        else {\n            this.window.scrollTo(x, y);\n        }\n    };\n    return NbLayoutComponent;\n}());\nexport { NbLayoutComponent };\n//# sourceMappingURL=layout.component.js.map\n",null]}